1、首先将.html文件转换为.jsp
2、将项目整体的包创建好，项目整体的三层架构
3、根据数据库book创建实体类
| id | title             | author     | price | sales | stock | img_path               |
4、使用数据库链接池，创建数据库链接：导入jar包
mysql-connector-java-5.1.37-bin.jar
c3p0-0.9.1.2.jar
使用C3P0数据源还要配置c3p0-config.xml配置文件
该文件中配置了数据库的链接信息
通过c3p0来获取数据库链接对象Connection
创建JdbcUtils，从中使用数据库链接池来获取Conneciton,和关闭链接
4、创建BookSerlvet、BookService、BookDao，然后把图书信息显示在index.jsp
创建BaseServlet，实现利用反射机制，根据方法名来执行对应的方法
在Dao的实现类中使用dbUtils实现增删改查,dbUtils中提供了一个QueryRunner对象，可以通过调用它的方法来执行sql语句
导入commons-dbutils-1.3.jar
创建BaseDao<T>，在里面使用QueryRunner来执行crud的操作，它的作用是不需要手动的传入Class对象
将获取的list存放到request域中
5、使用jstl标签库遍历,导入jar包
taglibs-standard-impl-1.2.5.jar
taglibs-standard-spec-1.2.5.jar
将图书全部显示在界面上后要使用分页
###########################################################分页
6、分页需要的实体类
Page<T>页面类
PageNo当前页
totalPageNo总页数，计算可得
totalRecord总记录数，查询可得
PAGE_SIZE每页显示多少条记录，固定
List<T>从数据库中查询的记录
7、在BookServlet中使用getPageBooks()替换getBooks()方法
在service层处理pageNo是否正确，如果是null,或者不能转换为int类型，那么就使用默认的1
然后创建一个Page<Book>，设置它的当前页，然后将它传入dao层
然后在dao层中一个方法中执行2条sql语句
查询总记录数
分页查询得到List<Book>
然后将查询结果设置给page对象，然后将它返回。
将index.jsp中遍历的对象${list}改为${page.list}
界面显示总记录数，总页数，设置上一页和下一页
8、设置jsp分页的高级显示12345页码
###########################################################管理员添加图书
###########################################################设置管理员权限
9、进入到后台管理需要首先登陆
10、使用Filter过滤器来判断是否登陆，而且判断是否时管理员
11、创建HttpFileter实现Filter接口,隐藏不必要的方法和进行类型转换
12、完成登陆判断
###########################################################管理员删除图书
###########################################################管理员修改图书
##########################################################Ajax注册验证用户名是否存在
##########################################################用户将图书加入购物车
购物项：
	-书名
	-数量
	-单价
	-金额:根据计算得到
购物车:
	-用户的id
	-购物项集合Map<String,购物项> 因为在做购物车中图书的数量修改的时候，我们要根据图书的id，来找到购物项
	-总商品数量 :根据计算得到
	-总金额:根据计算得到
13、创建CartServlet实现添加购物项的功能，购物车存放在Session域中
14、查看购物车功能
15、购物车中购物项的删除和清空购物车、购物项数量的修改
16、考虑一个问题:当查询订单和订单项是一对多的关系:如果我们封装的VO是一个带有订单表所有字段和
订单项集合List对象，那么我们使用原生的jdbc实现起来就比较复杂，但是我们使用Mybits实现起来
就比较容易:
--Mybatis
 a、可以进行左链接查询，然后自定义结果集，在resultMap中将list对象使用collections
标签进行封装，这里可以直接封装属性，需要注意的是ofType属性和某些字段主表和从表是否重名
，如果重名就要起别名。
 b、可以使用分步查询，首先查询出订单字段的所有信息，然后在自定义结果集resultMap中使用collections
 的select属性和column属性指定要调用的查询list集合的方法，column是指定要传入的字段。
--原生的JDBC
  a、分步查询，通过id查询出订单的所有信息，然后将信息设置到VO对象中，然后再根据id查询所有的order_id=id
 的订单项表，这样就查询出一个list集合，然后将它封装成ArrayList<Order_items>对象，最后将list对象设置到VO中
  b、考虑一下：因为是一对多的关系：所以使用做表链接查询的时候，查询出的可能是多条记录，然后这些记录的Order
  信息都相同，但是order_items都不同，但是我们只需要将Order_items的所有记录封装成一个list,但是order的信息
  不需要封装成list,而且这样显示查询出来的记录Order信息明显重复多余，我们只需要将多条记录中的任意一条记录的
  Order信息提取出然后封装到VO中即可。
  c、--VO对象如果设置成一个带有所有订单字段和订单项字段，这样我们使用链接查询的时候，就可以直接将查询的
  多条记录封装成一个List<VO>对象，这样就方便多了，只是这样ORM对象关系映射体现的不太好，因为是一对多的关系，
  所以这样体现的不是很好。
  
  
  
  
  
  
  
  
  
  